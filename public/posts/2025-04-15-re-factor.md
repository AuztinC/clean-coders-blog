---
title: "Re-factor"
date: "2025-04-15"
---

What makes something solid? The ability to resist change from outside forces? Maybe something that is independent and can stand alone or can be relied upon? Well, these seem like good values to instil in the design of our applications, don't they? The SOLID principles help define a design structure that if used will certainly help you get close to having most if not all parts of your application following these and many other great values.

Single Responsibility, or the principle that states that each module you build should have one and only one responsibility, and it should do that well. This is a fantastic way to build modules. By keeping all modules small and easy to understand we can decouple complicated logic and remove the overflow of un-needed resources or un-called functions. This principle alone leads you to an easy path to conforming to the Interface Segregation principle.

Open-Closed Principle, the rule that asks that your modules each have only the ability to be extended and not modified. When you are building modules that follow this principle, your modules behavior should be easy to change, while the source code of that module should not need modification. When you add a new feature to a system you should only have to add new code to the project, not go in and modify much of the existing source code. Building a system that isn't following this rule must be a real challenge.

Barbara Liskov wrote us a great list of rules that were later coined by Alan Coplien as the Liskov Substitution Principle. The idea that a subtype in a system should be able to be substituded in place of its parent and produce the same outcome. Any class that we extend from another should be able to sit in place of the original. If a base clase does something, any derivitive should do that also. Any derived class should be able to do more than the base class and not less.

The Interface Segregation Principle tells us that a class should not be forced to implement interfaces it does not need. This is huge for keeping a system decoupled and less cluttered overall.

Details should depend on high level policies while high level policies should never depends on the details of a system. The Dependency Inversion Principl separates extensible behavior behind abstract interface and then turn the dependancies around. This keeps us abstracting our policies out from the main applicaion and keeps business logic seperate from low level details.

After two hours of refactoring with Alex today, my Euler 4 or the fizzbuzz project code is looking WAY cleaner. The names, functions, tests are all improved! It was an extremely enlightening to see the power of some of clojures built in functins like for. I was shocked to see the simplicity of a recuring double for loops inside of a simple binding expression and printout. Changing names to be somehow what seems to be more simple and also descriptive was another take-away that I will keep with me.

A ton of lessons today and I'm happy to be getting them. Another great day of being an apprentice!