---
title: "SRP"
date: "2025-04-18"
---

The morning went by quick! I have found myself getting very worried about the use of Clojure itself. Spending a lot of time on my euler projects and repeating the fizzbuzz kata, even after having performed it. Presenting at lunch and learn was exciting. It was fun to get to share some analogies that the single responsibility principle had made me think of. Diving into my examples I found it easy to talk about the similarities in them. After finishing I was happy to receive some feedback that these were examples some others had not previously though about. Having to present just after Kristi made me a bit more nervous, as her presentation was very nice and colorful and mine was, well not. Admittedly, I feel that presentations such as these are a big weak point for myself. I need to acknowledge that and make progress at becoming better. Next Time, I will ask for more help in the ideas and layout of a presentation. Gina's feedback was not taken lightly, after thinking a lot about what she said I do believe that she made a good point. The examples I gave did not illustrate the need to keep overall business/operations responsibilies as a whole, separated.

After presenting and playing Fishbowl at the lunch and learn. I dove into euler #9, which was completed after recieving some advice about the wording of the problem itself. This problem has you find the 3 numbers that will add together to equal 1000 but are also a set of pythagorean triplet numbers. This was solved with a function that checks for pythagorean triplets on its own by taking in 3 numbers and comparing and calculating the algorithm. After this, a function 'test-triplets-under' was set up to make a nested loop with A, B, and C. A being the range to the incoming number. B, a range that starts above A and C which is the result of subtracting both A and B from the total incoming number. Resulting in a triple nested loop ensuring A is the smallest, B is second, and C is the largest of the three.

Euler #10, finding the sum of all prime numbers below 2 million. This problem turned out to be rather easy, as a couple of the previous problems have dealth with prime numbers. Creating a function check for prime numbers, I then used a function that looped to the incoming depth number and conj all prime numbers along the way. To speed this up I was only going to the Sqrt of the number being checked and also passed the collection with all previous primes as a parameter to result in less numbers being checked.